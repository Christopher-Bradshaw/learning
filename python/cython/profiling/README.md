# Profiling

1. Use runtime profiling (cProfile) to see what is slow in python.
2. Move slow code into cython if it is in python.
3. Turn on profiling for cython if you want to do runtime profiling there. You will most likely rely on on the output of `cythonize -a` though. Though runtime profiling isn't a bad sanity check.
4. Turn off profiling in cython!

## Runtime

First a reminder about normal python profiling. Note throughout we are using `cProfile` and not `profile`!

```
$ python3 -m cProfile -s tottime pure_python.py | head -n 12
3.141592653589819
         400223 function calls in 0.104 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.048    0.048    0.103    0.103 pure_python.py:6(integrate)
   200000    0.037    0.000    0.055    0.000 pure_python.py:3(sin_squared)
   200000    0.018    0.000    0.018    0.000 {built-in method math.sin}
        1    0.000    0.000    0.000    0.000 {built-in method _imp.create_dynamic}
        5    0.000    0.000    0.000    0.000 {built-in method posix.stat}
        4    0.000    0.000    0.000    0.000 <frozen importlib._bootstrap_external>:1233(find_spec)

```
About half the time is spent in integrate and the other half is shared between our sin_squared and math.sin. Almost no time is spent outside of integrate.

Let's try cythonize. Look at `cython_funcs_basic` which just copies the funcs over and compiles them. We get:

```
$ python3 -m cProfile -s tottime cython_main.py  | head -n 12
3.141592653589819
         326 function calls in 0.036 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.034    0.034    0.034    0.034 {cython_funcs_basic.integrate}
        2    0.000    0.000    0.000    0.000 {built-in method _imp.create_dynamic}
        7    0.000    0.000    0.000    0.000 {built-in method posix.stat}
        5    0.000    0.000    0.000    0.000 <frozen importlib._bootstrap_external>:1233(find_spec)
        2    0.000    0.000    0.000    0.000 <frozen importlib._bootstrap>:870(_find_spec)
        1    0.000    0.000    0.036    0.036 cython_main.py:1(<module>)

```

Ok that is absurd. Just by cythonizing we get a ~3x improvement. But where did all the function calls go? Profiling can't follow calls within the C code generated by cython so we don't see any detail below `integrate`.

We can get that detail back by adding a compiler directive `# cython: profile=True` - see `cython_funcs_basic_with_profiling`.pyx` file. Doing this we get:

```
$ python3 -m cProfile -s tottime cython_main.py  | head -n 12
3.141592653589819
         200328 function calls in 0.068 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.038    0.038    0.067    0.067 cython_funcs_basic_with_profiling.pyx:7(integrate)
   200000    0.029    0.000    0.029    0.000 cython_funcs_basic_with_profiling.pyx:4(sin_squared)
        2    0.000    0.000    0.000    0.000 {built-in method _imp.create_dynamic}
        7    0.000    0.000    0.000    0.000 {built-in method posix.stat}
        5    0.000    0.000    0.000    0.000 <frozen importlib._bootstrap_external>:1233(find_spec)
        2    0.000    0.000    0.000    0.000 <frozen importlib._bootstrap>:870(_find_spec)
```

Ok, we have found half of the function calls. We don't get the call to math.sin as that is an internal func - adding profiling only works for functions defined in the module. We also see total time increase by ~2x due to profiler overhead.

Now that we have info we can optimize! To do that we can use the compile time tools.

## Compile time

`cythonize -a` is incredible. Integrate it with your text editor. It shows what is slow. In `cython_funcs_fast_with_profiling` we follow the suggestions from this:

* Typing all numerical variables.
* Replacing the python `math.sin` with `libc.math.sin`

```
$ python3 -m cProfile -s tottime cython_main.py  | head -n 12
3.141592653589819
         200326 function calls in 0.041 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.025    0.025    0.040    0.040 cython_funcs_fast_with_profiling.pyx:7(integrate)
   200000    0.015    0.000    0.015    0.000 cython_funcs_fast_with_profiling.pyx:4(sin_squared)
        2    0.000    0.000    0.000    0.000 {built-in method _imp.create_dynamic}
        7    0.000    0.000    0.000    0.000 {built-in method posix.stat}
        5    0.000    0.000    0.000    0.000 <frozen importlib._bootstrap_external>:1233(find_spec)
        1    0.000    0.000    0.041    0.041 cython_main.py:1(<module>)
```

Interestingly, my idea of `cpdef`ing sin_squared increases call time! I suppose because it just adds a layer of indirection that we can't make sure of because we are passing the python func around. We are still pretty slow because of this (see comment in code). If this was real we might find some way of allowing the user to specify a `cdef`ed function - e.g. they pass a string and from that we choose a function. Or they just call a `integrate_sin_squared` function.

Removing profiling we get

```
$ python3 -m cProfile -s tottime cython_main.py  | head -n 12
3.141592653589819
         324 function calls in 0.013 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.012    0.012    0.012    0.012 {cython_funcs_fast_with_profiling.integrate}
        2    0.000    0.000    0.000    0.000 {built-in method _imp.create_dynamic}
        5    0.000    0.000    0.000    0.000 <frozen importlib._bootstrap_external>:1233(find_spec)
        7    0.000    0.000    0.000    0.000 {built-in method posix.stat}
        2    0.000    0.000    0.000    0.000 <frozen importlib._bootstrap>:870(_find_spec)
        1    0.000    0.000    0.013    0.013 cython_main.py:1(<module>)
```

~8x improvement over the pure python implementation with clear improvements available. If we provide an `integrate_sin_squared` we get down to (without profiling):

```
$ python3 -m cProfile -s tottime cython_main.py  | head -n 12
3.141592653589819
         324 function calls in 0.005 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.004    0.004    0.004    0.004 {cython_funcs_fast_with_profiling.integrate_sin_squared}
        2    0.000    0.000    0.000    0.000 {built-in method _imp.create_dynamic}
        7    0.000    0.000    0.000    0.000 {built-in method posix.stat}
        5    0.000    0.000    0.000    0.000 <frozen importlib._bootstrap_external>:1233(find_spec)
        1    0.000    0.000    0.005    0.005 cython_main.py:1(<module>)
        1    0.000    0.000    0.000    0.000 {built-in method builtins.print}
```

## Improving performance with directives
For a full list of compiler directives see https://cython.readthedocs.io/en/latest/src/reference/compilation.html#compiler-directives. These are very important for performance.
