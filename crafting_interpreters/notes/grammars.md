# Grammars ([wiki](https://en.wikipedia.org/wiki/Formal_grammar))

A grammar (or formal grammar) describes how to form strings from a language's alphabet that are valid given the language's syntax.
It is defined as a set of production rules for strings.


## Components of Grammars

* A finite set N of nonterminal symbols (I'll use uppercase for these)
* A finite set Σ of terminal symbols (I'll use lowercase for these)
* A finite set P of production rules that maps nonterminals to some combination of nonterminals and terminals (this is not quite right, but I'm ok ignoring some of the details)
* A symbol S (S ∈ N) that is the start symbol.

The grammar is formally defined as the tuple (N, Σ, P, S).

## Chomsky Hierarchy ([wiki](https://en.wikipedia.org/wiki/Chomsky_hierarchy))

Grammars can be arranged in a hierachy based on how complicated the production rules are.
Remember we write nonterminals with uppercase, terminals with lowercase, and greek letters are a string (optionally empty) of some combination of these two.

### Regular (Type 3) ([wiki](https://en.wikipedia.org/wiki/Regular_grammar))

A regular grammar has rules of the form:

* A → a (nonterminal to terminal)
* A → aB (this is for a right regular grammar - if we had Ba it would be left regular)

These languages can be decided (what is this) by a finite state automaton or obtained by regular expressions.

### Context Free (Type 2) ([wiki](https://en.wikipedia.org/wiki/Context-free_grammar))

A context-free grammar has rules of the form:

* A → α

These are context free as the nonterminal's mapping is independent of the surrounding values.

### Context Sensitive (Type 1)

A context-sensitive grammar has rules of the form:

* αAβ → αγβ

Note that while the context does not change, the γ that A maps to might depend on that context!

We don't need to know about these grammars as I don't think they are used in programming languages.


## Lox's Grammar

For the parser, we can describe a grammar using [EBNF](https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form). I don't really know EBNF so there might be some bugs, but hopefully it is clear.

To see the grammar of a real programming language in full detail, see [Python's](https://docs.python.org/3/reference/grammar.html).

### Simple Expressions

First, a simple example,

```
literal -> NUMBER | STRING | "true" | "false" | "nil" ;
```

which we read as "a literal is a nonterminal that produces either a NUMBER, STRING (whihc are also nonterminals that should probably be defined), or a couple of specific strings."

Now a set of rules that allow us to generate (or parse) simple expresssions.

```
expression → literal | unary | binary | grouping ;
literal → NUMBER | STRING | "true" | "false" | "nil" ;
grouping → "(" expression ")"
binary → expression operator expression
unary → ( "-" | "!" ) expression ;
operator → "+" | "-" | "==" | ... ;
```

So for example, this let's us generate

```
1 + 3 * 5
```

However, while it is easy to *generate strings* given this grammar, the grammar is ambiguous, which makes it impossible to uniquely identify *how* we got to that string.
The above string could have been generated by,

```
( binary ( binary 1 + 3 ) * 5 ) ⇒ 20
( binary 1 + ( binary 3 * 5 ) ) ⇒ 16
```

The binary rule as written does not make it clear how the expressions nest - they can do it either way. To unambiguate this grammar we need to define rules of,

* **Precedence**: Defines which operation is evaluated first in a series of *different* operators. In the above example, using the normal mathematical rules of precendence, we would parse it as
`( binary 1 + ( binary 3 * 5 ) ) ⇒ 16`.
* **Associativity**: Defined which operation is evaluated first in a series of *the same* operators. Consider `a = b = c`. We choose to define the `=` is right associative meaning that the rightmost operator evaluates first. The parse tree becomes,
`( binary a = ( binary b = c ) )`.

There are two ways to un ambiguity the grammar. Keep the grammar as is and filter the possible trees using these rules, or modify the grammar so that it encodes these rules. We will do the latter.

### Expressions accounting for precendence

To account for these, we first need to define them. Starting from lowest precendence,

| Name              | Operators             | Associates            |
| ----------------- | --------------------- | --------------------- |
| Equality          | `==` `!=`             | Left                  |
| Comparison        | `<` `<=` `>` `>=`     | Left                  |
| Term (??)         | `-` `+`               | Left                  |
| Factor            | `/` `*`               | Left                  |
| Unary             | `!` `-`               | Right                 |

We now need define the production rules. Let's just think about factors. At first we might thing we could do something like,

```
factor → expression ( "/" | "*" ) expression ;
```

but this would match strings like `a + b * c + d` where the addition happens first. Instead, matches for factor shohuld only allow **higher** priority operations to the left and right. This is the pattern we will follow -- operators will only match adjcacent expressions with higher priority.
We also need to match repeated operators such as `a * b * c`. Remember that `( abc )*` means match 0 or more of what is inside the brackets.
So,

```
expression  → equality ;
equality    → comparison ( ( "==" | "!=" ) comparison )* ;
comparison  → term ( ( "<" "<=" ">" ">=" ) term )* ;
term        → factor ( ( "-" | "+" ) factor )* ;
factor      → unary ( ( "/" | "*" ) unary )* ;
unary       → ( "!" | "-" ) unary | primary ;
primary     → NUMBER | STRING | "true" | "false" | "nil" | "(" expression ")" ;
```
